[{"id":0,"href":"/tutorials/forking-a-debian-package/","title":"Forking a Debian Package","parent":"Tutorials","content":"Debian is an operating system with a rich packaging format and dependency resolution system. It runs on the Linux kernel and provides over 80,000 packages. Packages ranging from shells like bash, server software like nginx, desktop software like Firefox, and even full-blown desktop environments like Gnome. The Ubuntu operating system is a Debian variant which adopts many of the same packages as Debian, providing a commercial facade and a different, potentially favorable package lifecycle. Every two years Ubuntu names a Long Term Support (LTS) release, in this article we\u0026rsquo;ll focus on Ubuntu 22.04 codenamed Jammy, an LTS supported through 2027.\nRDKit is a C++ library and suite of Java/Python modules. Unfortunately Ubuntu Jammy is providing RDKit 202109 and will not update the major version. Ubuntu releases pin their entire dependency tree except for bug and security patches. The RDKit-rs project needs to be flexible and stay up to date on RDKit changes upstream. We anticipate finding bugs and potentially customizing the RDKit C++ to meet our needs. In short, the RDKit-rs project needs a lot more control over RDKit.\nHow can we fork a Debian package?     Forking is a very common thing to solve in the world of git, you just hit the fork button on Github and copy the repository to your account. Or perhaps you need to fork a docker image? You can either layer your changes on top of the original image or you can take the Dockerfile and customize it to your needs, with easy distribution through docker push/docker pull to a repository. Unfortunately things are not so easy in the Debian world.\nWe\u0026rsquo;ll need to understand:\n what a Debian package is how to build a package how RDKit is packaged how to distribute custom Debian packages. We won\u0026rsquo;t cover starting a package from scratch.  Debian Source Packages     One goal of Debian is to run herd on the 80,000+ open source packages. Debian does not maintain forks of these projects, instead preferring static snapshots of the package source code. Source code is packaged as an untouched .tar.gz and can be uploaded to Debian repositories for download by clients.\nOnce the source is packaged it\u0026rsquo;s time to answer the questions \u0026ldquo;how do we build something usable out of this source code?\u0026rdquo;. No need to learn how to build every piece of software, the mechanical steps are captured by the Debian packaging rules. And similarly, no need to manually fetch build-time and run-time dependencies for software, those can be tracked by the Debian package description.\nBuilding A Binary Package From Source     A classic Debian packaging project laid out on disk might look like:\n# apt-get source bash # tree . |-- bash-5.1 | |-- ABOUT-NLS | |-- AUTHORS |-- bash_5.1-6ubuntu1.debian.tar.xz |-- bash_5.1-6ubuntu1.dsc `-- bash_5.1.orig.tar.xz  The bash-5.1 directory is unpacked for your convenience using the .orig.tar.xz. You will need to be inside this directory to build the package.\nThe bash_5.1-6ubuntu1.debian.tar.xz contains all the Debian patches and build instructions. This is a big source of value as it provides a common surface to the package and once you learn how the parts work you can customize any package.\nThe bash_5.1-6ubuntu1.dsc contains the metadata like build-depends so you can easily fetch required packages to build the software, or depends for required packages to run the software. It also includes security features like GPG signature from the packaging author.\nAnd finally bash_5.1.orig.tar.xz is the untouched snapshot of the source code from the upstream project. No need to go the bash website to fetch this software, and no need to worry about the software project deleting a version of software.\nBuild the software with the packaging rules as-is:\n# ls bash-5.1 bash_5.1-6ubuntu1.debian.tar.xz bash_5.1-6ubuntu1.dsc bash_5.1.orig.tar.xz # cd bash-5.1 bash-5.1 # dpkg-buildpackage [[ SNIP ]] dpkg-checkbuilddeps: error: Unmet build dependencies: bison libncurses5-dev texinfo texi2html sharutils locales time texlive-latex-base ghostscript texlive-fonts-recommended man2html-base  The Debian packaging system doesn\u0026rsquo;t need to build the software to know we don\u0026rsquo;t have all our prerequisites. We can just install those with the following:\napt-get install -y bison libncurses5-dev texinfo texi2html sharutils locales time texlive-latex-base ghostscript texlive-fonts-recommended man2html-base  In the future we\u0026rsquo;ll use mechanisms that auto install build dependencies. But after running that install manually we try again:\nbash-5.1# dpkg-buildpackage dpkg-buildpackage: info: source package bash dpkg-buildpackage: info: source version 5.1-6ubuntu1 dpkg-buildpackage: info: source distribution jammy dpkg-buildpackage: info: source changed by Matthias Klose \u0026lt;doko@ubuntu.com\u0026gt; dpkg-buildpackage: info: host architecture arm64 [[[ SNIP ]]] Beginning configuration for bash-5.1-release for aarch64-unknown-linux-gnu checking for gcc... gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether gcc accepts -g... yes  What\u0026rsquo;s great is that we don\u0026rsquo;t know all the details for how bash is built. No wrangling autotools, cmake, Makefile, etc. The goal of building a binary has been boiled down to invoking dpkg-buildpackage. And for the most part you will use pre-built binaries from the Debian or Ubuntu build farms.\nMixing In An Updated Package     It\u0026rsquo;s great to be able to pull down the source code from the operating system\u0026rsquo;s repositories. But the development of that package must happen somewhere, new package versions don\u0026rsquo;t just snap in to existence, they flow from less stable releases to more stable releases over time.\nIf we could just grab that latest work, take responsibility for its contents, we could build it ourselves and hit fast-forward on versions.\nUnfortunately, at this time of writing, I\u0026rsquo;m not sure where Ubuntu collaborates on packaging definitions. But we know that Debian packages migrate to Ubuntu over time and it\u0026rsquo;s safe to assume Debian is the originator of the RDKit packaging definition.\nEnter salsa.debian.org, a gitlab installation and modern home for collaborating on packages in a format that might be familiar to software developers. Specifically we can look at the DebiChem Pure Blend (a special interest group focused on making \u0026ldquo;Debian a good platform for chemists in their day-to-day work\u0026rdquo;) and more specifically we can look at the DebiChem Salsa Organization and their RDkit project.\n","description":"Debian is an operating system with a rich packaging format and dependency resolution system. It runs on the Linux kernel and provides over 80,000 packages. Packages ranging from shells like bash, server software like nginx, desktop software like Firefox, and even full-blown desktop environments like Gnome. The Ubuntu operating system is a Debian variant which adopts many of the same packages as Debian, providing a commercial facade and a different, potentially favorable package lifecycle."},{"id":1,"href":"/","title":"RDKit-rs","parent":"","content":"{{ range .Pages }}  {{.Date.Format \u0026ldquo;2006-01-02\u0026rdquo;}} | {{.Title}}  {{ end }}\n \nThe power and speed of RDKit, the safety of Rust! A combination of low level C++ bindings and useful high level Rust constructs so you can\n Parse mol/molblocks Normalize Fingerprint Enumerate tautomers/canonicalize  How does it work?   The rdkit-rs project provides two key libraries: rdkit and rdkit-sys. The sys package is a collection of low or zero-cost wrappers exposing a key subset of the RDKit C++ functionality. The rdkit package builds on top of the sys package, hiding pointers and providing idiomatic Rust interfaces (think: Debug and Clone implementations, smart borrowing behavior).\nWith the rdkit library you will never need to manually free memory or worry about accessing null pointers. You also get all the benefits of an optimizing compiler and will never wait for garbage collection.\nExample   in your Cargo.toml:\n[dependencies] rdkit = \u0026#34;*\u0026#34; If you satisfy the requirements below, the following code should just compile!\nuserdkit::{Properties,ROMol};pubfn main(){letmol=ROMol::from_smile(\u0026#34;c1ccccc1C(=O)NC\u0026#34;).unwrap();letproperties=Properties::new();letcomputed: HashMap\u0026lt;String,f64\u0026gt;=properties.compute_properties(\u0026amp;mol);assert_eq!(*computed.get(\u0026#34;NumAtoms\u0026#34;).unwrap(),19.0);}Browse more rdkit-rs/rdkit examples\nRequirements   We support recent stable Rust versions. The limiting factor is whatever our C++ bindings library, cxx-rs, supports. Check the cxx Cargo.toml to confirm what rust-version is supported.\nRequires a recent version of RDKit, tested against 2022.03.1. Supports both static and dynamic linking, preferring static linking. You can use a copy of RDKit installed either from Mac homebrew or Conda Forge. We are working to get Debian packages updated for the most recent RDKit and also including static libraries so we can build portable RDKit applications.\n brew install rdkit conda install -c conda-forge rdkit==2022.03.1  Ubuntu support is coming soon.\nYou will also need a compiler for building the sys package\u0026rsquo;s C++ bridge. We recommend clang for the compilation speed.\nWhy Rust?   Rust is a powerful systems level programming language, offering a smart static typing system, an integrated build system and package manager, and strong memory safety, among many other benefits. Read more about Rust in the free Rust Book.\nIssues?   Please file an issue on GitHub\n","description":"{{ range .Pages }}  {{.Date.Format \u0026ldquo;2006-01-02\u0026rdquo;}} | {{.Title}}  {{ end }}\n \nThe power and speed of RDKit, the safety of Rust! A combination of low level C++ bindings and useful high level Rust constructs so you can\n Parse mol/molblocks Normalize Fingerprint Enumerate tautomers/canonicalize  How does it work?   The rdkit-rs project provides two key libraries: rdkit and rdkit-sys. The sys package is a collection of low or zero-cost wrappers exposing a key subset of the RDKit C++ functionality."},{"id":2,"href":"/tags/","title":"Tags","parent":"RDKit-rs","content":"","description":""},{"id":3,"href":"/tutorials/","title":"Tutorials","parent":"RDKit-rs","content":"","description":""}]