[{"id":0,"href":"/tutorials/forking-a-debian-package/","title":"Forking a Debian Package","parent":"Tutorials","content":"Debian is an operating system with a rich packaging format and dependency resolution system. It runs on the Linux kernel and provides over 80,000 packages. Packages ranging from shells like bash, server software like nginx, desktop software like Firefox, and even full-blown desktop environments like Gnome. The Ubuntu operating system is a Debian variant which adopts many of the same packages as Debian, providing a commercial facade and a different, potentially favorable package lifecycle. Every two years Ubuntu names a Long Term Support (LTS) release, in this article we\u0026rsquo;ll focus on Ubuntu 22.04 codenamed Jammy, an LTS supported through 2027.\nRDKit is a C++ library and suite of Java/Python modules. Unfortunately Ubuntu Jammy is providing RDKit 202109 and will not update the major version. Ubuntu releases pin their entire dependency tree except for bug and security patches. The RDKit-rs project needs to be flexible and stay up to date on RDKit changes upstream. We anticipate finding bugs and potentially customizing the RDKit C++ to meet our needs. In short, the RDKit-rs project needs a lot more control over RDKit.\nHow can we fork a Debian package?     Forking is a very common thing to solve in the world of git, you just hit the fork button on Github and copy the repository to your account. Or perhaps you need to fork a docker image? You can either layer your changes on top of the original image or you can take the Dockerfile and customize it to your needs, with easy distribution through docker push/docker pull to a repository. Unfortunately things are not so easy in the Debian world.\nWe\u0026rsquo;ll need to understand:\n what a Debian package is how to build a package how RDKit is packaged how to distribute custom Debian packages. We won\u0026rsquo;t cover starting a package from scratch.  Debian Source Packages     One goal of Debian is to run herd on the 80,000+ open source packages. Debian does not maintain forks of these projects, instead preferring static snapshots of the package source code. Source code is packaged as an untouched .tar.gz and can be uploaded to Debian repositories for download by clients.\nOnce the source is packaged it\u0026rsquo;s time to answer the questions \u0026ldquo;how do we build something usable out of this source code?\u0026rdquo;. No need to learn how to build every piece of software, the mechanical steps are captured by the Debian packaging rules. And similarly, no need to manually fetch build-time and run-time dependencies for software, those can be tracked by the Debian package description.\nBuilding A Binary Package From Source     A classic Debian packaging project laid out on disk might look like:\n# apt-get source bash # tree . |-- bash-5.1 | |-- ABOUT-NLS | |-- AUTHORS |-- bash_5.1-6ubuntu1.debian.tar.xz |-- bash_5.1-6ubuntu1.dsc `-- bash_5.1.orig.tar.xz  The bash-5.1 directory is unpacked for your convenience using the .orig.tar.xz. You will need to be inside this directory to build the package.\nThe bash_5.1-6ubuntu1.debian.tar.xz contains all the Debian patches and build instructions. This is a big source of value as it provides a common surface to the package and once you learn how the parts work you can customize any package.\nThe bash_5.1-6ubuntu1.dsc contains the metadata like build-depends so you can easily fetch required packages to build the software, or depends for required packages to run the software. It also includes security features like GPG signature from the packaging author.\nAnd finally bash_5.1.orig.tar.xz is the untouched snapshot of the source code from the upstream project. No need to go the bash website to fetch this software, and no need to worry about the software project deleting a version of software.\nBuild the software with the packaging rules as-is:\n# ls bash-5.1 bash_5.1-6ubuntu1.debian.tar.xz bash_5.1-6ubuntu1.dsc bash_5.1.orig.tar.xz # cd bash-5.1 bash-5.1 # dpkg-buildpackage [[ SNIP ]] dpkg-checkbuilddeps: error: Unmet build dependencies: bison libncurses5-dev texinfo texi2html sharutils locales time texlive-latex-base ghostscript texlive-fonts-recommended man2html-base  The Debian packaging system doesn\u0026rsquo;t need to build the software to know we don\u0026rsquo;t have all our prerequisites. We can just install those with the following:\napt-get install -y bison libncurses5-dev texinfo texi2html sharutils locales time texlive-latex-base ghostscript texlive-fonts-recommended man2html-base  In the future we\u0026rsquo;ll use mechanisms that auto install build dependencies. But after running that install manually we try again:\nbash-5.1# dpkg-buildpackage dpkg-buildpackage: info: source package bash dpkg-buildpackage: info: source version 5.1-6ubuntu1 dpkg-buildpackage: info: source distribution jammy dpkg-buildpackage: info: source changed by Matthias Klose \u0026lt;doko@ubuntu.com\u0026gt; dpkg-buildpackage: info: host architecture arm64 [[[ SNIP ]]] Beginning configuration for bash-5.1-release for aarch64-unknown-linux-gnu checking for gcc... gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether gcc accepts -g... yes  What\u0026rsquo;s great is that we don\u0026rsquo;t know all the details for how bash is built. No wrangling autotools, cmake, Makefile, etc. The goal of building a binary has been boiled down to invoking dpkg-buildpackage. And for the most part you will use pre-built binaries from the Debian or Ubuntu build farms.\nFinding Updated Packages     It\u0026rsquo;s great to be able to pull down the source code from the operating system\u0026rsquo;s repositories. But the development of that package must happen somewhere, new package versions don\u0026rsquo;t just snap in to existence, they flow from less stable releases to more stable releases over time.\nIf we could just grab that latest work, take responsibility for its contents, we could build it ourselves and hit fast-forward on versions.\nUnfortunately, at this time of writing, I\u0026rsquo;m not sure where Ubuntu collaborates on packaging definitions. But we know that Debian packages migrate to Ubuntu over time, and it\u0026rsquo;s safe to assume Debian is the originator of the RDKit packaging definition.\nEnter salsa.debian.org, a gitlab installation and modern home for collaborating on packages in a format that might be familiar to software developers. Specifically we can look at the DebiChem Pure Blend (a special interest group focused on making \u0026ldquo;Debian a good platform for chemists in their day-to-day work\u0026rdquo;) and more specifically we can look at the DebiChem Salsa Organization and their RDkit project.\nWe\u0026rsquo;re going to take the RDKit definition from Salsa and make it our own.\nUsing git to build source packages     In our opening bash example we were able to pull sources from our regular repository and just build the software. But when package definitions are tracked in git we have to use modified techniques. And luckily for us the tooling around packages in git is quite mature and just the right kind of esoteric.\nThe RDKit salsa repository carries on the tradition of tracking snapshots of the upstream source code \u0026ndash; the repository does not track the official RDKit repository, instead RDKit on Salsa unpacks static releases and tracks their contents as-is. It does not carry any commit history from upstream.\nEach official RDKit release is tracked with a corresponding tag. For example, RDKit 202209.3 gets the tag 202209.3. But in the master branch there is a mix of RDKit C++ code and Debian packaging description in the debian folder. The tree looks something like this:\n% tree . . ├── CMakeLists.txt ├── CTestConfig.cmake ├── CTestCustom.ctest.in ├── Code │ ├── CMakeLists.txt [[ SNIP ]] ├── debian │ ├── TODO │ ├── changelog │ ├── clean │ ├── control │ ├── control.in │ ├── copyright │ ├── gbp.conf │ ├── librdkit-dev.install │ ├── librdkit1.install │ ├── librdkit1.lintian-overrides │ ├── patches │ │ ├── NoDownloads.patch [[ SNIP ]] │ ├── pgversions │ ├── python-rdkit.links │ ├── rdkit-data.install │ ├── rdkit-doc.dirs │ ├── rdkit-doc.doc-base │ ├── rules │ ├── salsa-ci.yml │ ├── source │ │ ├── format │ │ └── lintian-overrides │ ├── tests │ │ ├── control │ │ └── installcheck │ ├── upstream │ │ └── metadata │ └── watch  Updating to a newer RDKit release would essential mean clobbering everything outside the debian/ directory with the contents of the Release_YYYY_MM_B.zip downloaded from the RDKit GitHub releases. It does seem messy to throw away the commit history of the repository but Debian is only interest in packaging defined releases, something considered stable software by the source authors.\nWe can use gbp (aka, git-buildpackage) to take a tag, build a source .orig.tar.xz and then apply the debian/ rules to construct a binary package. Think of it like a git-centric workflow using the dpkg-buildpackage from before alongside a variety of quality-improving tools we\u0026rsquo;ll cover as we go.\nBut let\u0026rsquo;s grab rdkit from salsa:\n# apt-get install -y git-buildpackage # git clone https://salsa.debian.org/debichem-team/rdkit.git # cd rdkit/  First we\u0026rsquo;ll consider the top entry in the debian/changelog, this will dictate the version assigned to the package:\n# cat debian/changelog rdkit (202209.3-2) UNRELEASED; urgency=medium -- Debichem Team \u0026lt;debichem-devel@lists.alioth.debian.org\u0026gt; Sat, 14 Jan 2023 13:33:42 +0100  So the changelog doesn\u0026rsquo;t say much for humans, but it gives the version (202209.3-2), author (Debichem Team) and the date the changelog was generated (Sat, 14 Jan 2023 13:33:42 +0100). So we expect if we use the right incantations we can build rdkit 202209.3-2.\nrdkit # gbp buildpackage gbp:error: Pristine-tar couldn't verify \u0026quot;rdkit_202209.3.orig.tar.xz\u0026quot;: fatal: path 'rdkit_202209.3.orig.tar.xz.delta' does not exist in 'refs/remotes/origin/pristine-tar' pristine-tar: git show refs/remotes/origin/pristine-tar:rdkit_202209.3.orig.tar.xz.delta failed  I don\u0026rsquo;t know why we need a pristine tar ref. So we can tell gbp to skip it and try again:\nrdkit# gbp buildpackage --git-no-pristine-tar gbp:info: Performing the build debuild: warning: debian/changelog(l4): found trailer where expected start of change data LINE: -- Debichem Team \u0026lt;debichem-devel@lists.alioth.debian.org\u0026gt; Sat, 14 Jan 2023 13:33:42 +0100 dpkg-buildpackage -us -uc -ui -i -I dpkg-buildpackage: warning: debian/changelog(l4): found trailer where expected start of change data [[[ SNIP ]]] dpkg-buildpackage -us -uc -ui -i -I failed gbp:error: 'debuild -i -I' failed: it exited with 29  Ah, our old friend dpkg-buildpackage shows up again. But it fails, it looks like the debian changelog is not suitable for a build just yet (submitting broken code happens!), we can edit the changelog:\nrdkit# cat debian/changelog | head -n 10 rdkit (202209.3-2) UNRELEASED; urgency=medium * Just filling this in -- Debichem Team \u0026lt;debichem-devel@lists.alioth.debian.org\u0026gt; Sat, 14 Jan 2023 13:33:42 +0100  And try again:\nrdkit # gbp buildpackage --git-no-pristine-tar gbp:error: You have uncommitted changes in your source tree: gbp:error: On branch master Your branch is up to date with 'origin/master'.  Turns out the process of running buildpackage had applied patches and dirtied our git checkout, making gbp suspicious the project was no longer suitable for release. We can add on another flag to ignore dirty changes in the git repo:\nrdkit # gbp buildpackage --git-no-pristine-tar --git-ignore-new [[[ SNIP ]]] dpkg-checkbuilddeps: error: Unmet build dependencies: catch2 cmake dh-python doxygen flex imagemagick latexmk libboost-dev libboost-iostreams-dev libboost-python-dev libboost-regex-dev libboost-system-dev libboost-thread-dev libcairo-dev libcoordgen-dev libeigen3-dev libfreetype6-dev libmaeparser-dev librsvg2-bin libsqlite3-dev pandoc postgresql-server-dev-all python3-dev python3-numpy python3-pandas python3-pil | python3-imaging python3-recommonmark python3-sphinx python3-sqlalchemy rapidjson-dev texlive-latex-extra texlive-latex-recommended dpkg-buildpackage: warning: build dependencies/conflicts unsatisfied; aborting  And again we have an error, similar to the bash build before we are missing dependencies required to compile the code. The tools won\u0026rsquo;t automatically install the build dependencies as that could be messy in a dev environment. Why don\u0026rsquo;t we just jump to sandboxing a build, no need in potentially muddying up a developers OS.\nSandboxing A Build     We want to build our software but we don\u0026rsquo;t want to muddy up the base OS. Fortunately debootstrap can populate a fresh filesystem inside a directory, a perfect OS for using chroot and friends to \u0026ldquo;move into\u0026rdquo; a sandbox. The gbp tool prefers to use cowbuilder for moving into a sandbox, making it easy to track changes done while building and then resetting the changes, avoiding a potentially expensive debootstrap to recreate the filesystem.\nrdkit# gbp buildpackage --git-no-pristine-tar --git-ignore-new --git-pbuilder gbp:info: Building with (cowbuilder) for sid gbp:info: Performing the build Base directory /var/cache/pbuilder/base.cow does not exist gbp:error: 'git-pbuilder' failed: it exited with 1  We have to bootstrap that chroot jail ourselves:\nrdkit# DIST=jammy git-pbuilder create I: Invoking pbuilder I: forking: pbuilder create --buildplace /var/cache/pbuilder/base-jammy.cow --mirror http://ports.ubuntu.com/ubuntu-ports/ --distribution jammy --no-targz --extrapackages cowdancer  \u0026ndash;git-no-pristine-tar\nFurther reading      http://honk.sigxcpu.org/projects/git-buildpackage/manual-html/gbp.html  ","description":"Debian is an operating system with a rich packaging format and dependency resolution system. It runs on the Linux kernel and provides over 80,000 packages. Packages ranging from shells like bash, server software like nginx, desktop software like Firefox, and even full-blown desktop environments like Gnome. The Ubuntu operating system is a Debian variant which adopts many of the same packages as Debian, providing a commercial facade and a different, potentially favorable package lifecycle."},{"id":1,"href":"/","title":"RDKit-rs","parent":"","content":"{{ range .Pages }}  {{.Date.Format \u0026ldquo;2006-01-02\u0026rdquo;}} | {{.Title}}  {{ end }}\n \nThe power and speed of RDKit, the safety of Rust! A combination of low level C++ bindings and useful high level Rust constructs so you can\n Parse mol/molblocks Normalize Fingerprint Enumerate tautomers/canonicalize  How does it work?   The rdkit-rs project provides two key libraries: rdkit and rdkit-sys. The sys package is a collection of low or zero-cost wrappers exposing a key subset of the RDKit C++ functionality. The rdkit package builds on top of the sys package, hiding pointers and providing idiomatic Rust interfaces (think: Debug and Clone implementations, smart borrowing behavior).\nWith the rdkit library you will never need to manually free memory or worry about accessing null pointers. You also get all the benefits of an optimizing compiler and will never wait for garbage collection.\nExample   in your Cargo.toml:\n[dependencies] rdkit = \u0026#34;*\u0026#34; If you satisfy the requirements below, the following code should just compile!\nuserdkit::{Properties,ROMol};pubfn main(){letmol=ROMol::from_smile(\u0026#34;c1ccccc1C(=O)NC\u0026#34;).unwrap();letproperties=Properties::new();letcomputed: HashMap\u0026lt;String,f64\u0026gt;=properties.compute_properties(\u0026amp;mol);assert_eq!(*computed.get(\u0026#34;NumAtoms\u0026#34;).unwrap(),19.0);}Browse more rdkit-rs/rdkit examples\nRequirements   We support recent stable Rust versions. The limiting factor is whatever our C++ bindings library, cxx-rs, supports. Check the cxx Cargo.toml to confirm what rust-version is supported.\nRequires a recent version of RDKit, tested against 2022.03.1. Supports both static and dynamic linking, preferring static linking. You can use a copy of RDKit installed either from Mac homebrew or Conda Forge. We are working to get Debian packages updated for the most recent RDKit and also including static libraries so we can build portable RDKit applications.\n brew install rdkit conda install -c conda-forge rdkit==2022.03.1  Ubuntu support is coming soon.\nYou will also need a compiler for building the sys package\u0026rsquo;s C++ bridge. We recommend clang for the compilation speed.\nWhy Rust?   Rust is a powerful systems level programming language, offering a smart static typing system, an integrated build system and package manager, and strong memory safety, among many other benefits. Read more about Rust in the free Rust Book.\nIssues?   Please file an issue on GitHub\n","description":"{{ range .Pages }}  {{.Date.Format \u0026ldquo;2006-01-02\u0026rdquo;}} | {{.Title}}  {{ end }}\n \nThe power and speed of RDKit, the safety of Rust! A combination of low level C++ bindings and useful high level Rust constructs so you can\n Parse mol/molblocks Normalize Fingerprint Enumerate tautomers/canonicalize  How does it work?   The rdkit-rs project provides two key libraries: rdkit and rdkit-sys. The sys package is a collection of low or zero-cost wrappers exposing a key subset of the RDKit C++ functionality."},{"id":2,"href":"/tags/","title":"Tags","parent":"RDKit-rs","content":"","description":""},{"id":3,"href":"/tutorials/","title":"Tutorials","parent":"RDKit-rs","content":"","description":""}]